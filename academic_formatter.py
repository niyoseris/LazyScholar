#!/usr/bin/env python3
"""
Academic Formatter - A tool to format LazyScholar's final paper as a proper academic paper

This script:
1. Reads the final paper generated by LazyScholar
2. Reformats it as a proper academic paper with in-text citations
3. Formats the references section according to APA style
4. Creates a new version of the final paper with academic formatting
"""

import os
import re
import logging
import argparse
from pathlib import Path
import google.generativeai as genai
from dotenv import load_dotenv
import json
import PyPDF2
import requests
import time

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("academic_formatter.log")
    ]
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
if not GOOGLE_API_KEY:
    logger.error("GOOGLE_API_KEY not found in environment variables. Please set it in .env file.")
    exit(1)

# Configure Google Generative AI
genai.configure(api_key=GOOGLE_API_KEY)

def initialize_model():
    """Initialize the Gemini model for content analysis."""
    try:
        # Set up generation config
        generation_config = {
            "temperature": 0.2,  # Lower temperature for more consistent output
            "top_p": 0.95,
            "top_k": 40,
            "max_output_tokens": 8192,
        }
        
        # Initialize the model
        model = genai.GenerativeModel(
            model_name="gemini-2.0-flash-001",
            generation_config=generation_config,
        )
        logger.info("Successfully initialized Gemini model")
        return model
    except Exception as e:
        logger.error(f"Failed to initialize Gemini model: {str(e)}")
        return None

def extract_metadata_from_pdf(pdf_path):
    """Extract metadata from a PDF file."""
    try:
        import PyPDF2
        metadata = {}
        
        with open(pdf_path, 'rb') as file:
            reader = PyPDF2.PdfReader(file)
            
            # Extract text from first page to try to get title and authors
            if len(reader.pages) > 0:
                first_page_text = reader.pages[0].extract_text()
                
                # Try to extract title (usually at the top of the first page)
                title_lines = first_page_text.split('\n')[:3]  # First 3 lines might contain the title
                metadata['title'] = ' '.join(title_lines).strip()
                
                # Try to get publication year from filename or content
                year_pattern = re.compile(r'(19|20)\d{2}')  # Match years from 1900-2099
                year_matches = year_pattern.findall(os.path.basename(pdf_path))
                if year_matches:
                    metadata['year'] = year_matches[0]
                else:
                    # Try to find year in first page text
                    year_matches = year_pattern.findall(first_page_text[:500])  # Check first 500 chars
                    if year_matches:
                        metadata['year'] = year_matches[0]
                    else:
                        metadata['year'] = "n.d."  # No date
                
                # Try to extract authors
                # Look for common patterns like "by" or "Author:" in first 500 chars
                author_section = first_page_text[:500]
                author_pattern = re.compile(r'(?:by|authors?:|written by)[:\s]+([^,\.;]+(?:,\s*[^,\.;]+){0,5})', re.IGNORECASE)
                author_match = author_pattern.search(author_section)
                if author_match:
                    metadata['authors'] = author_match.group(1).strip()
                else:
                    # Just use the filename as a fallback
                    base_name = os.path.basename(pdf_path).replace('.pdf', '')
                    metadata['authors'] = base_name.split('_')[0] if '_' in base_name else base_name
            
            # Try to get info from PDF metadata
            if reader.metadata:
                if '/Title' in reader.metadata and reader.metadata['/Title']:
                    metadata['title'] = reader.metadata['/Title']
                if '/Author' in reader.metadata and reader.metadata['/Author']:
                    metadata['authors'] = reader.metadata['/Author']
                if '/CreationDate' in reader.metadata and reader.metadata['/CreationDate']:
                    date_str = reader.metadata['/CreationDate']
                    year_match = year_pattern.search(date_str)
                    if year_match:
                        metadata['year'] = year_match.group(0)
        
        return metadata
    except Exception as e:
        logger.error(f"Error extracting metadata from PDF {pdf_path}: {str(e)}")
        # Return basic metadata based on filename
        base_name = os.path.basename(pdf_path).replace('.pdf', '')
        parts = base_name.split('_')
        return {
            'title': ' '.join(parts[1:]) if len(parts) > 1 else base_name,
            'authors': parts[0] if len(parts) > 1 else "Unknown",
            'year': "n.d."
        }

def extract_references_from_final_paper(final_paper_path):
    """Extract the current references from the final paper and find corresponding PDFs."""
    try:
        with open(final_paper_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Get the PDF directory
        pdf_dir = os.path.join(os.path.dirname(os.path.dirname(final_paper_path)), "pdfs")
        
        # Get all PDF files in the directory
        pdf_files = []
        if os.path.exists(pdf_dir):
            pdf_files = [os.path.join(pdf_dir, f) for f in os.listdir(pdf_dir) if f.endswith('.pdf')]
        
        # If no PDFs found, try to find any PDF mentions in the content
        if not pdf_files:
            pdf_pattern = re.compile(r'([^\/\s]+\.pdf)')
            for match in pdf_pattern.finditer(content):
                pdf_file = match.group(1)
                pdf_path = os.path.join(pdf_dir, pdf_file)
                if os.path.exists(pdf_path) and pdf_path not in pdf_files:
                    pdf_files.append(pdf_path)
        
        # Extract existing citations from the content
        # Look for both APA style citations and old SOURCE format
        citation_patterns = [
            re.compile(r'\(([^)]+?, \d{4})\)'),  # APA style (Author, Year)
            re.compile(r'(\d+\.\s+[^(]+\(\d{4}\)[^\.]+\.)'),  # Numbered reference: 1. Author (Year). Title.
            re.compile(r'SOURCE \d+: ([^\.]+\.pdf)'),  # Old SOURCE format
        ]
        
        citations = set()
        for pattern in citation_patterns:
            for match in pattern.finditer(content):
                citation = match.group(1)
                citations.add(citation)
        
        logger.info(f"Found {len(citations)} citations in the paper")
        logger.info(f"Found {len(pdf_files)} PDF files in the directory")
        
        logger.info(f"Extracted {len(pdf_files)} PDF references from the final paper")
        return pdf_files, content
    except Exception as e:
        logger.error(f"Error extracting references: {str(e)}")
        return [], ""

def generate_academic_citations(pdf_paths):
    """Generate academic citations in APA format based on PDF metadata."""
    citations = []
    
    for pdf_path in pdf_paths:
        try:
            metadata = extract_metadata_from_pdf(pdf_path)
            
            # Format authors
            authors = metadata.get('authors', 'Unknown')
            if ',' in authors:
                # Multiple authors separated by commas
                author_text = authors
            else:
                # Single author or authors not properly formatted
                author_text = authors
            
            # Format title
            title = metadata.get('title', os.path.basename(pdf_path).replace('.pdf', ''))
            
            # Format year
            year = metadata.get('year', 'n.d.')
            
            # Create citation in APA format
            citation = f"{author_text} ({year}). {title}."
            
            citations.append(citation)
        except Exception as e:
            logger.error(f"Error generating citation for {pdf_path}: {str(e)}")
            # Create a basic citation from the filename
            base_name = os.path.basename(pdf_path).replace('.pdf', '')
            citations.append(f"{base_name}. (n.d.).")
    
    return citations

def format_as_academic_paper(model, content, pdf_paths):
    """Format the content as an academic paper with in-text citations."""
    try:
        # Generate proper academic citations
        citations = generate_academic_citations(pdf_paths)
        
        # If no citations were found, extract existing citations from the content
        if not citations:
            # Check if there are already formatted citations in the content
            references_section_match = re.search(r'## References\s*\n(.*?)(?:\n\n|\Z|$)', content, re.DOTALL)
            if references_section_match:
                references_section = references_section_match.group(1).strip()
                # If references section has content, use it
                if references_section:
                    # Extract individual references
                    reference_pattern = re.compile(r'(?:\d+\.\s+)?(.*?)(?:\n|$)')
                    for match in reference_pattern.finditer(references_section):
                        ref = match.group(1).strip()
                        if ref and len(ref) > 10:  # Arbitrary minimum length to filter out noise
                            citations.append(ref)
            
            # If still no citations, generate placeholder citations based on topics
            if not citations:
                # Extract topics from content
                topic_pattern = re.compile(r'## ([^\n]+)')
                topics = [match.group(1) for match in topic_pattern.finditer(content)]
                
                # Common section names to exclude
                common_sections = ['abstract', 'introduction', 'conclusion', 'references', 'keywords', 
                                  'literature review', 'methodology', 'results', 'discussion']
                
                # Generate placeholder citations for each topic
                for topic in topics:
                    if topic.lower() not in common_sections:
                        author = topic.split()[0] if topic else "Author"
                        citations.append(f"{author} et al. (2023). Research on {topic}. Journal of Electronic Materials.")
        
        # Extract title and problem statement
        title_match = re.search(r'^# (.+?)$', content, re.MULTILINE)
        title = title_match.group(1) if title_match else "Research Paper"
        
        # Create a prompt for the model to format the paper
        prompt = f"""
        Format the following research paper as an academic document with proper citations and structure.
        
        Original paper title: {title}
        
        The paper should include:
        1. Title
        2. Abstract
        3. Keywords
        4. Introduction
        5. Literature Review
        6. Methodology
        7. Results
        8. Discussion
        9. Conclusion
        10. References (in APA format)
        
        Original content:
        {content}
        
        For the references section, use these citations in proper APA style:
        {json.dumps(citations, indent=2)}
        
        The output should be in Markdown format.
        
        Important: For any citations that are already in proper academic format (e.g., "Author et al. (2023). Title."), 
        keep them as is. Only reformat citations that are in non-academic format (e.g., filenames or URLs).
        """
        
        # Generate the formatted paper
        response = model.generate_content(prompt)
        formatted_paper = response.text
        
        logger.info("Successfully formatted the paper as an academic document")
        return formatted_paper
    except Exception as e:
        logger.error(f"Error formatting as academic paper: {str(e)}")
        return content

def save_formatted_paper(final_paper_path, formatted_paper):
    """Save the formatted paper to a new file."""
    try:
        # Create the output path
        output_path = final_paper_path.replace(".md", "_academic_format.md")
        
        # Write the formatted paper
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(formatted_paper)
        
        logger.info(f"Saved formatted academic paper to {output_path}")
        return output_path
    except Exception as e:
        logger.error(f"Error saving formatted paper: {str(e)}")
        return None

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Format LazyScholar's final paper as an academic paper")
    parser.add_argument(
        "--input",
        default="research_output/final_paper.md",
        help="Path to the input final paper (default: research_output/final_paper.md)"
    )
    return parser.parse_args()

def main():
    """Main function to format the final paper as an academic paper."""
    logger.info("Starting academic paper formatting process...")
    
    # Parse arguments
    args = parse_arguments()
    
    # Initialize model
    model = initialize_model()
    if not model:
        logger.error("Failed to initialize model. Exiting.")
        return
    
    # Check if input file exists
    final_paper_path = args.input
    if not os.path.exists(final_paper_path):
        logger.error(f"Final paper not found at {final_paper_path}")
        return
    
    # Extract references and content
    pdf_paths, content = extract_references_from_final_paper(final_paper_path)
    
    # Format as academic paper
    formatted_paper = format_as_academic_paper(model, content, pdf_paths)
    
    # Save formatted paper
    output_path = save_formatted_paper(final_paper_path, formatted_paper)
    if output_path:
        logger.info(f"Successfully created academic paper at {output_path}")
        print(f"\nAcademic paper created at: {output_path}")
    else:
        logger.error("Failed to create academic paper")

if __name__ == "__main__":
    main() 