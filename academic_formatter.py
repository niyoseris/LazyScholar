#!/usr/bin/env python3
"""
Academic Formatter - A tool to format LazyScholar's final paper as a proper academic paper

This script:
1. Reads the final paper generated by LazyScholar
2. Reformats it as a proper academic paper with in-text citations
3. Formats the references section according to APA style
4. Creates a new version of the final paper with academic formatting
"""

import os
import re
import logging
import argparse
from pathlib import Path
import google.generativeai as genai
from dotenv import load_dotenv
import json
import PyPDF2
import requests
import time

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("academic_formatter.log")
    ]
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
if not GOOGLE_API_KEY:
    logger.error("GOOGLE_API_KEY not found in environment variables. Please set it in .env file.")
    exit(1)

# Configure Google Generative AI
genai.configure(api_key=GOOGLE_API_KEY)

def initialize_model():
    """Initialize the Gemini model for content analysis."""
    try:
        # Set up generation config
        generation_config = {
            "temperature": 0.2,  # Lower temperature for more consistent output
            "top_p": 0.95,
            "top_k": 40,
            "max_output_tokens": 8192,
        }
        
        # Initialize the model
        model = genai.GenerativeModel(
            model_name="gemini-2.0-flash-001",
            generation_config=generation_config,
        )
        logger.info("Successfully initialized Gemini model")
        return model
    except Exception as e:
        logger.error(f"Failed to initialize Gemini model: {str(e)}")
        return None

def extract_metadata_from_pdf(pdf_path):
    """Extract metadata from a PDF file."""
    try:
        import PyPDF2
        metadata = {}
        
        with open(pdf_path, 'rb') as file:
            reader = PyPDF2.PdfReader(file)
            
            # Extract text from first page to try to get title and authors
            if len(reader.pages) > 0:
                first_page_text = reader.pages[0].extract_text()
                
                # Try to extract title (usually at the top of the first page)
                title_lines = first_page_text.split('\n')[:3]  # First 3 lines might contain the title
                metadata['title'] = ' '.join(title_lines).strip()
                
                # Try to get publication year from filename or content
                year_pattern = re.compile(r'(19|20)\d{2}')  # Match years from 1900-2099
                year_matches = year_pattern.findall(os.path.basename(pdf_path))
                if year_matches:
                    metadata['year'] = year_matches[0]
                else:
                    # Try to find year in first page text
                    year_matches = year_pattern.findall(first_page_text[:500])  # Check first 500 chars
                    if year_matches:
                        metadata['year'] = year_matches[0]
                    else:
                        metadata['year'] = "n.d."  # No date
                
                # Try to extract authors
                # Look for common patterns like "by" or "Author:" in first 500 chars
                author_section = first_page_text[:500]
                author_pattern = re.compile(r'(?:by|authors?:|written by)[:\s]+([^,\.;]+(?:,\s*[^,\.;]+){0,5})', re.IGNORECASE)
                author_match = author_pattern.search(author_section)
                if author_match:
                    metadata['authors'] = author_match.group(1).strip()
                else:
                    # Just use the filename as a fallback
                    base_name = os.path.basename(pdf_path).replace('.pdf', '')
                    metadata['authors'] = base_name.split('_')[0] if '_' in base_name else base_name
            
            # Try to get info from PDF metadata
            if reader.metadata:
                if '/Title' in reader.metadata and reader.metadata['/Title']:
                    metadata['title'] = reader.metadata['/Title']
                if '/Author' in reader.metadata and reader.metadata['/Author']:
                    metadata['authors'] = reader.metadata['/Author']
                if '/CreationDate' in reader.metadata and reader.metadata['/CreationDate']:
                    date_str = reader.metadata['/CreationDate']
                    year_match = year_pattern.search(date_str)
                    if year_match:
                        metadata['year'] = year_match.group(0)
        
        return metadata
    except Exception as e:
        logger.error(f"Error extracting metadata from PDF {pdf_path}: {str(e)}")
        # Return basic metadata based on filename
        base_name = os.path.basename(pdf_path).replace('.pdf', '')
        parts = base_name.split('_')
        return {
            'title': ' '.join(parts[1:]) if len(parts) > 1 else base_name,
            'authors': parts[0] if len(parts) > 1 else "Unknown",
            'year': "n.d."
        }

def extract_references_from_final_paper(final_paper_path):
    """Extract the current references from the final paper and find corresponding PDFs."""
    try:
        with open(final_paper_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Get the PDF directory - check multiple possible locations
        possible_pdf_dirs = [
            os.path.join(os.path.dirname(os.path.dirname(final_paper_path)), "pdfs"),
            os.path.join(os.path.dirname(final_paper_path), "pdfs"),
            os.path.join(os.path.dirname(final_paper_path), "..", "pdfs")
        ]
        
        pdf_files = []
        for pdf_dir in possible_pdf_dirs:
            if os.path.exists(pdf_dir):
                pdf_files.extend([os.path.join(pdf_dir, f) for f in os.listdir(pdf_dir) if f.endswith('.pdf')])
                logger.info(f"Found {len(pdf_files)} PDF files in {pdf_dir}")
                break
        
        # If no PDFs found in standard directories, search for PDF mentions in the content
        if not pdf_files:
            pdf_pattern = re.compile(r'([^\/\s]+\.pdf)')
            pdf_mentions = set()
            for match in pdf_pattern.finditer(content):
                pdf_mentions.add(match.group(1))
            
            if pdf_mentions:
                logger.info(f"Found {len(pdf_mentions)} PDF mentions in the paper")
                # Try to locate these PDFs
                for pdf_dir in possible_pdf_dirs:
                    if os.path.exists(pdf_dir):
                        for pdf_file in pdf_mentions:
                            pdf_path = os.path.join(pdf_dir, pdf_file)
                            if os.path.exists(pdf_path) and pdf_path not in pdf_files:
                                pdf_files.append(pdf_path)
        
        # Extract references section
        references = []
        references_match = re.search(r'## References\s*\n(.*?)(?:\n#|\Z)', content, re.DOTALL)
        if references_match:
            references_section = references_match.group(1).strip()
            
            # Extract individual references with various patterns
            ref_patterns = [
                # Numbered references
                re.compile(r'(?:^|\n)(?:\d+\.\s+)?(.*?)(?=\n\d+\.|$)', re.DOTALL),
                # Topic-subtopic references
                re.compile(r'\*\*.*?\*\*:\s*(.*?)(?=\n\*\*|\Z)', re.DOTALL)
            ]
            
            for pattern in ref_patterns:
                for match in pattern.finditer(references_section):
                    ref_text = match.group(1).strip()
                    if ref_text and not ref_text.startswith("No references"):
                        # Split multi-line references
                        for ref in ref_text.split('\n'):
                            ref = ref.strip()
                            if ref:
                                references.append(ref)
            
            logger.info(f"Extracted {len(references)} references from the paper")
        
        # Extract in-text citations
        citation_patterns = [
            re.compile(r'\(([^)]+?, \d{4}[a-z]?)\)'),  # APA style (Author, Year)
            re.compile(r'([A-Z][a-z]+ et al\., \d{4})'),  # Author et al., Year
        ]
        
        citations = set()
        for pattern in citation_patterns:
            for match in pattern.finditer(content):
                citation = match.group(1).strip()
                citations.add(citation)
        
        logger.info(f"Found {len(citations)} in-text citations in the paper")
        
        return pdf_files, content
    except Exception as e:
        logger.error(f"Error extracting references: {str(e)}")
        return [], ""

def generate_academic_citations(pdf_paths):
    """Generate academic citations in APA format based on PDF metadata."""
    citations = []
    
    for pdf_path in pdf_paths:
        try:
            metadata = extract_metadata_from_pdf(pdf_path)
            
            # Format authors
            authors = metadata.get('authors', '')
            if not authors or authors == "Unknown":
                # Try to extract author from filename
                base_name = os.path.basename(pdf_path).replace('.pdf', '')
                parts = base_name.split('_')
                if len(parts) > 1:
                    authors = parts[0].replace('-', ' ').title()
                else:
                    authors = "Unknown Author"
            
            # Clean up authors
            authors = re.sub(r'[_\-]', ' ', authors)
            
            # Format title
            title = metadata.get('title', '')
            if not title or len(title) < 5:
                # Use filename as title
                base_name = os.path.basename(pdf_path).replace('.pdf', '')
                parts = base_name.split('_')
                if len(parts) > 1:
                    title = ' '.join(parts[1:]).replace('-', ' ').title()
                else:
                    title = base_name.replace('-', ' ').title()
            
            # Clean up title
            title = re.sub(r'[_\-]', ' ', title)
            
            # Format year
            year = metadata.get('year', '')
            if not year or year == "n.d.":
                # Try to extract year from filename or title
                year_pattern = re.compile(r'(19|20)\d{2}')
                year_match = year_pattern.search(os.path.basename(pdf_path))
                if year_match:
                    year = year_match.group(0)
                elif year_pattern.search(title):
                    year = year_pattern.search(title).group(0)
                else:
                    year = "n.d."
            
            # Create citation in APA format
            if ',' in authors:
                # Multiple authors
                citation = f"{authors} ({year}). {title}."
            else:
                # Single author
                citation = f"{authors} ({year}). {title}."
            
            citations.append(citation)
        except Exception as e:
            logger.error(f"Error generating citation for {pdf_path}: {str(e)}")
            # Create a basic citation from the filename
            base_name = os.path.basename(pdf_path).replace('.pdf', '')
            parts = base_name.split('_')
            if len(parts) > 1:
                author = parts[0].replace('-', ' ').title()
                title = ' '.join(parts[1:]).replace('-', ' ').title()
                citations.append(f"{author} (n.d.). {title}.")
            else:
                citations.append(f"{base_name.replace('-', ' ').title()} (n.d.).")
    
    return citations

def format_as_academic_paper(model, content, pdf_paths):
    """Format the content as an academic paper with in-text citations."""
    try:
        # Step 1: Parse the original paper structure
        sections = {}
        current_section = None
        section_content = []
        title = None
        
        # Extract title and sections
        for line in content.split('\n'):
            if line.startswith('# '):
                title = line[2:].strip()
            elif line.startswith('## '):
                # Save previous section if any
                if current_section:
                    sections[current_section] = section_content
                
                # Start new section
                current_section = line[3:].strip()
                section_content = []
            elif current_section:
                section_content.append(line)
        
        # Save the last section
        if current_section and section_content:
            sections[current_section] = section_content
        
        # Step 2: Extract existing references
        references = []
        if "References" in sections:
            ref_content = '\n'.join(sections["References"])
            # Extract references with various patterns
            ref_patterns = [
                # Numbered references
                re.compile(r'(?:^|\n)(?:\d+\.\s+)?(.*?)(?=\n\d+\.|$)', re.DOTALL),
                # Topic-subtopic references
                re.compile(r'\*\*.*?\*\*:\s*(.*?)(?=\n\*\*|\Z)', re.DOTALL)
            ]
            
            for pattern in ref_patterns:
                for match in pattern.finditer(ref_content):
                    ref_text = match.group(1).strip()
                    if ref_text and not ref_text.startswith("No references"):
                        # Split multi-line references
                        for ref in ref_text.split('\n'):
                            ref = ref.strip()
                            if ref and len(ref) > 5:  # Minimal length check
                                references.append(ref)
        
        # Step 3: Extract citations from PDF metadata
        pdf_citations = []
        for pdf_path in pdf_paths:
            try:
                metadata = extract_metadata_from_pdf(pdf_path)
                
                # Format authors
                authors = metadata.get('authors', 'Unknown')
                
                # Format title
                title_text = metadata.get('title', os.path.basename(pdf_path).replace('.pdf', ''))
                
                # Format year
                year = metadata.get('year', 'n.d.')
                
                # Create citation in APA format
                citation = f"{authors} ({year}). {title_text}."
                pdf_citations.append(citation)
            except Exception as e:
                logger.warning(f"Error creating citation for {pdf_path}: {str(e)}")
        
        # Step 4: Combine all references, removing duplicates
        all_references = []
        seen_refs = set()
        
        # Process existing references first
        for ref in references:
            # Clean up reference
            ref = re.sub(r'^SOURCE \d+:\s*', '', ref)  # Remove SOURCE prefix
            ref = re.sub(r'^\d+\.\s+', '', ref)  # Remove numbering
            
            # Skip if empty or too short
            if not ref or len(ref) < 5:
                continue
                
            # Check if it's a filename
            if ref.lower().endswith('.pdf'):
                # Try to find a better citation for this PDF
                found_better = False
                for pdf_citation in pdf_citations:
                    if ref.lower() in pdf_citation.lower():
                        if pdf_citation not in seen_refs:
                            seen_refs.add(pdf_citation)
                            all_references.append(pdf_citation)
                            found_better = True
                            break
                
                # If no better citation found, use as is
                if not found_better and ref not in seen_refs:
                    seen_refs.add(ref)
                    all_references.append(ref)
            else:
                # Use the reference as is if not already included
                if ref not in seen_refs:
                    seen_refs.add(ref)
                    all_references.append(ref)
        
        # Add remaining PDF citations
        for citation in pdf_citations:
            if citation not in seen_refs:
                seen_refs.add(citation)
                all_references.append(citation)
        
        # Step 5: Create a better prompt for academic formatting
        prompt = f"""
        Enhance the following research paper to meet academic standards while PRESERVING ALL ORIGINAL CONTENT.
        
        IMPORTANT INSTRUCTIONS:
        1. DO NOT change the paper's structure or reorganize sections
        2. DO NOT remove any content or findings from the original paper
        3. DO NOT add new content that wasn't in the original paper
        4. DO improve the academic tone and language
        5. DO format in-text citations properly as (Author, Year)
        6. DO ensure all citations have corresponding entries in the references list
        7. DO maintain all technical details and specialized terminology
        
        Original paper title: {title or "Research Paper"}
        
        Original content:
        {content}
        
        References to include (format these properly in APA style):
        {json.dumps(all_references, indent=2)}
        
        The output should be in Markdown format with the same structure as the original paper.
        """
        
        # Step 6: Generate the formatted paper
        response = model.generate_content(prompt)
        formatted_paper = response.text
        
        # Step 7: Ensure references are properly included
        if "## References" not in formatted_paper and all_references:
            formatted_paper += "\n\n## References\n\n"
            for i, ref in enumerate(all_references, 1):
                formatted_paper += f"{i}. {ref}\n\n"
        
        logger.info("Successfully formatted the paper as an academic document")
        return formatted_paper
    except Exception as e:
        logger.error(f"Error formatting as academic paper: {str(e)}")
        # Return original content if formatting fails
        return content

def save_formatted_paper(final_paper_path, formatted_paper):
    """Save the formatted paper to a new file."""
    try:
        # Create the output path
        output_path = final_paper_path.replace(".md", "_academic_format.md")
        
        # Write the formatted paper
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(formatted_paper)
        
        logger.info(f"Saved formatted academic paper to {output_path}")
        return output_path
    except Exception as e:
        logger.error(f"Error saving formatted paper: {str(e)}")
        return None

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Format LazyScholar's final paper as an academic paper")
    parser.add_argument(
        "--input",
        default="research_output/final_paper.md",
        help="Path to the input final paper (default: research_output/final_paper.md)"
    )
    parser.add_argument(
        "--preserve-structure",
        action="store_true",
        default=True,
        help="Preserve the original paper structure (default: True)"
    )
    return parser.parse_args()

def main():
    """Main function to format the final paper as an academic paper."""
    logger.info("Starting academic paper formatting process...")
    
    # Parse arguments
    args = parse_arguments()
    
    # Initialize model
    model = initialize_model()
    if not model:
        logger.error("Failed to initialize model. Exiting.")
        return
    
    # Check if input file exists
    final_paper_path = args.input
    if not os.path.exists(final_paper_path):
        logger.error(f"Final paper not found at {final_paper_path}")
        return
    
    try:
        # Extract references and content
        logger.info(f"Extracting references from {final_paper_path}")
        pdf_paths, content = extract_references_from_final_paper(final_paper_path)
        
        if not content:
            logger.error("Failed to read content from the paper")
            return
            
        logger.info(f"Found {len(pdf_paths)} PDF files for citation generation")
        
        # Format as academic paper
        logger.info("Formatting paper as academic document...")
        formatted_paper = format_as_academic_paper(model, content, pdf_paths)
        
        # Validate the formatted paper
        if not formatted_paper or len(formatted_paper) < 100:
            logger.error("Formatting failed - output is too short or empty")
            return
            
        # Save formatted paper
        output_path = save_formatted_paper(final_paper_path, formatted_paper)
        if output_path:
            logger.info(f"Successfully created academic paper at {output_path}")
            print(f"\nAcademic paper created at: {output_path}")
            
            # Provide a summary of changes
            original_lines = len(content.split('\n'))
            formatted_lines = len(formatted_paper.split('\n'))
            print(f"\nSummary of changes:")
            print(f"- Original paper: {original_lines} lines")
            print(f"- Formatted paper: {formatted_lines} lines")
            print(f"- References processed: {len(pdf_paths)}")
            
            # Check if references section exists
            if "## References" in formatted_paper:
                ref_section = formatted_paper.split("## References")[1]
                ref_count = len(re.findall(r'\n\d+\.', ref_section))
                print(f"- References included: {ref_count}")
            else:
                print("- Warning: No References section found in formatted paper")
        else:
            logger.error("Failed to create academic paper")
    except Exception as e:
        logger.error(f"Error in academic formatting process: {str(e)}", exc_info=True)
        print(f"\nError: {str(e)}")
        print("Please check the academic_formatter.log file for details.")

if __name__ == "__main__":
    main() 