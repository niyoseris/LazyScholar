#!/usr/bin/env python3
"""
Academic Formatter - A tool to format LazyScholar's final paper as a proper academic paper

This script:
1. Reads the final paper generated by LazyScholar
2. Reformats it as a proper academic paper with in-text citations
3. Formats the references section according to APA style
4. Creates a new version of the final paper with academic formatting
"""

import os
import re
import logging
import argparse
from pathlib import Path
import google.generativeai as genai
from dotenv import load_dotenv
import json
import PyPDF2
import requests
import time

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("academic_formatter.log")
    ]
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
if not GOOGLE_API_KEY:
    logger.error("GOOGLE_API_KEY not found in environment variables. Please set it in .env file.")
    exit(1)

# Configure Google Generative AI
genai.configure(api_key=GOOGLE_API_KEY)

def initialize_model():
    """Initialize the Gemini model for content analysis."""
    try:
        # Set up generation config
        generation_config = {
            "temperature": 0.2,  # Lower temperature for more consistent output
            "top_p": 0.95,
            "top_k": 40,
            "max_output_tokens": 8192,
        }
        
        # Initialize the model
        model = genai.GenerativeModel(
            model_name="gemini-2.0-flash-001",
            generation_config=generation_config,
        )
        logger.info("Successfully initialized Gemini model")
        return model
    except Exception as e:
        logger.error(f"Failed to initialize Gemini model: {str(e)}")
        return None

def extract_metadata_from_pdf(pdf_path):
    """Extract metadata from a PDF file."""
    try:
        import PyPDF2
        metadata = {}
        
        with open(pdf_path, 'rb') as file:
            reader = PyPDF2.PdfReader(file)
            
            # Extract text from first page to try to get title and authors
            if len(reader.pages) > 0:
                first_page_text = reader.pages[0].extract_text()
                
                # Try to extract title (usually at the top of the first page)
                title_lines = first_page_text.split('\n')[:3]  # First 3 lines might contain the title
                metadata['title'] = ' '.join(title_lines).strip()
                
                # Try to get publication year from filename or content
                year_pattern = re.compile(r'(19|20)\d{2}')  # Match years from 1900-2099
                year_matches = year_pattern.findall(os.path.basename(pdf_path))
                if year_matches:
                    metadata['year'] = year_matches[0]
                else:
                    # Try to find year in first page text
                    year_matches = year_pattern.findall(first_page_text[:500])  # Check first 500 chars
                    if year_matches:
                        metadata['year'] = year_matches[0]
                    else:
                        metadata['year'] = "n.d."  # No date
                
                # Try to extract authors
                # Look for common patterns like "by" or "Author:" in first 500 chars
                author_section = first_page_text[:500]
                author_pattern = re.compile(r'(?:by|authors?:|written by)[:\s]+([^,\.;]+(?:,\s*[^,\.;]+){0,5})', re.IGNORECASE)
                author_match = author_pattern.search(author_section)
                if author_match:
                    metadata['authors'] = author_match.group(1).strip()
                else:
                    # Just use the filename as a fallback
                    base_name = os.path.basename(pdf_path).replace('.pdf', '')
                    metadata['authors'] = base_name.split('_')[0] if '_' in base_name else base_name
            
            # Try to get info from PDF metadata
            if reader.metadata:
                if '/Title' in reader.metadata and reader.metadata['/Title']:
                    metadata['title'] = reader.metadata['/Title']
                if '/Author' in reader.metadata and reader.metadata['/Author']:
                    metadata['authors'] = reader.metadata['/Author']
                if '/CreationDate' in reader.metadata and reader.metadata['/CreationDate']:
                    date_str = reader.metadata['/CreationDate']
                    year_match = year_pattern.search(date_str)
                    if year_match:
                        metadata['year'] = year_match.group(0)
        
        return metadata
    except Exception as e:
        logger.error(f"Error extracting metadata from PDF {pdf_path}: {str(e)}")
        # Return basic metadata based on filename
        base_name = os.path.basename(pdf_path).replace('.pdf', '')
        parts = base_name.split('_')
        return {
            'title': ' '.join(parts[1:]) if len(parts) > 1 else base_name,
            'authors': parts[0] if len(parts) > 1 else "Unknown",
            'year': "n.d."
        }

def extract_references_from_final_paper(final_paper_path):
    """Extract the current references from the final paper and find corresponding PDFs."""
    try:
        with open(final_paper_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Get the PDF directory
        pdf_dir = os.path.join(os.path.dirname(os.path.dirname(final_paper_path)), "pdfs")
        
        # Get all PDF files in the directory
        pdf_files = []
        if os.path.exists(pdf_dir):
            pdf_files = [os.path.join(pdf_dir, f) for f in os.listdir(pdf_dir) if f.endswith('.pdf')]
        
        # Extract references section
        references_match = re.search(r'## References\s*\n(.*?)(?:\n#|\Z)', content, re.DOTALL)
        if references_match:
            references_section = references_match.group(1).strip()
            
            # Extract individual references
            references = []
            # Pattern for numbered references
            ref_pattern = re.compile(r'(?:^|\n)(?:\d+\.\s+)?(.*?)(?=\n\d+\.|$)', re.DOTALL)
            for match in ref_pattern.finditer(references_section):
                ref = match.group(1).strip()
                if ref and not ref.startswith("No references"):
                    references.append(ref)
            
            logger.info(f"Extracted {len(references)} references from the paper")
            
            # Try to match references to PDF files
            matched_pdfs = []
            for pdf_path in pdf_files:
                pdf_name = os.path.basename(pdf_path)
                # Check if PDF filename appears in any reference
                for ref in references:
                    if pdf_name.lower() in ref.lower():
                        matched_pdfs.append(pdf_path)
                        break
            
            # If we couldn't match PDFs by name, include all PDFs
            if not matched_pdfs and pdf_files:
                matched_pdfs = pdf_files
                logger.info(f"Using all {len(matched_pdfs)} available PDFs for citation generation")
            else:
                logger.info(f"Matched {len(matched_pdfs)} PDFs to references")
            
            return matched_pdfs, content
        else:
            logger.warning("No References section found in the paper")
            return pdf_files, content
    except Exception as e:
        logger.error(f"Error extracting references: {str(e)}")
        return [], ""

def generate_academic_citations(pdf_paths):
    """Generate academic citations in APA format based on PDF metadata."""
    citations = []
    
    for pdf_path in pdf_paths:
        try:
            metadata = extract_metadata_from_pdf(pdf_path)
            
            # Format authors
            authors = metadata.get('authors', 'Unknown')
            if ',' in authors:
                # Multiple authors separated by commas
                author_text = authors
            else:
                # Single author or authors not properly formatted
                author_text = authors
            
            # Format title
            title = metadata.get('title', os.path.basename(pdf_path).replace('.pdf', ''))
            
            # Format year
            year = metadata.get('year', 'n.d.')
            
            # Create citation in APA format
            citation = f"{author_text} ({year}). {title}."
            
            citations.append(citation)
        except Exception as e:
            logger.error(f"Error generating citation for {pdf_path}: {str(e)}")
            # Create a basic citation from the filename
            base_name = os.path.basename(pdf_path).replace('.pdf', '')
            citations.append(f"{base_name}. (n.d.).")
    
    return citations

def format_as_academic_paper(model, content, pdf_paths):
    """Format the content as an academic paper with in-text citations."""
    try:
        # Extract existing structure and content
        sections = {}
        current_section = "preamble"
        sections[current_section] = []
        
        # Parse the original content to preserve structure
        for line in content.split('\n'):
            if line.startswith('# '):
                # Main title
                sections["title"] = line[2:].strip()
            elif line.startswith('## '):
                # Section heading
                current_section = line[3:].strip().lower()
                sections[current_section] = []
            elif line.startswith('### '):
                # Subsection - add to current section with formatting
                sections[current_section].append(line)
            else:
                # Regular content
                if current_section in sections:
                    sections[current_section].append(line)
        
        # Extract existing references
        references = []
        if "references" in sections:
            ref_content = '\n'.join(sections["references"])
            # Extract numbered references
            ref_pattern = re.compile(r'(?:^|\n)(?:\d+\.\s+)?(.*?)(?=\n\d+\.|$)', re.DOTALL)
            for match in ref_pattern.finditer(ref_content):
                ref = match.group(1).strip()
                if ref and not ref.startswith("No references"):
                    references.append(ref)
        
        # Add citations from PDF metadata if available
        pdf_citations = generate_academic_citations(pdf_paths)
        
        # Combine all references, removing duplicates
        all_references = []
        seen_refs = set()
        
        # First add existing references from the paper
        for ref in references:
            normalized = re.sub(r'^\**.*?\**:\s*', '', ref).strip()  # Remove topic/subtopic prefixes
            if normalized and normalized not in seen_refs:
                seen_refs.add(normalized)
                all_references.append(ref)
        
        # Then add references from PDF metadata
        for ref in pdf_citations:
            normalized = ref.lower()
            # Check if this reference is already included (approximate matching)
            is_duplicate = False
            for existing in seen_refs:
                # Simple similarity check - if 70% of words match, consider it a duplicate
                ref_words = set(normalized.split())
                existing_words = set(existing.lower().split())
                if len(ref_words) > 0 and len(existing_words) > 0:
                    common_words = ref_words.intersection(existing_words)
                    similarity = len(common_words) / min(len(ref_words), len(existing_words))
                    if similarity > 0.7:
                        is_duplicate = True
                        break
            
            if not is_duplicate:
                seen_refs.add(normalized)
                all_references.append(ref)
        
        # Extract title
        title = sections.get("title", "Research Paper")
        
        # Create a more flexible prompt for academic formatting
        prompt = f"""
        Enhance the following research paper to meet academic standards while preserving its original content and structure.
        
        Paper title: {title}
        
        IMPORTANT GUIDELINES:
        1. Preserve ALL original content and insights
        2. Maintain the existing section structure where possible
        3. Ensure all in-text citations use proper academic format (Author, Year)
        4. Connect in-text citations to the references list
        5. Improve language for clarity and academic tone
        6. Format the paper in proper academic style
        7. DO NOT invent new content or findings
        8. DO NOT remove substantive content
        
        Original paper structure:
        {json.dumps({k: len(v) for k, v in sections.items()}, indent=2)}
        
        Original content:
        {content}
        
        References to include (in APA format):
        {json.dumps(all_references, indent=2)}
        
        The output should be in Markdown format.
        """
        
        # Generate the formatted paper
        response = model.generate_content(prompt)
        formatted_paper = response.text
        
        # Ensure references are properly included
        if "## References" not in formatted_paper:
            formatted_paper += "\n\n## References\n\n"
            for i, ref in enumerate(all_references, 1):
                formatted_paper += f"{i}. {ref}\n\n"
        
        logger.info("Successfully formatted the paper as an academic document")
        return formatted_paper
    except Exception as e:
        logger.error(f"Error formatting as academic paper: {str(e)}")
        # Return original content if formatting fails
        return content

def save_formatted_paper(final_paper_path, formatted_paper):
    """Save the formatted paper to a new file."""
    try:
        # Create the output path
        output_path = final_paper_path.replace(".md", "_academic_format.md")
        
        # Write the formatted paper
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(formatted_paper)
        
        logger.info(f"Saved formatted academic paper to {output_path}")
        return output_path
    except Exception as e:
        logger.error(f"Error saving formatted paper: {str(e)}")
        return None

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="Format LazyScholar's final paper as an academic paper")
    parser.add_argument(
        "--input",
        default="research_output/final_paper.md",
        help="Path to the input final paper (default: research_output/final_paper.md)"
    )
    return parser.parse_args()

def main():
    """Main function to format the final paper as an academic paper."""
    logger.info("Starting academic paper formatting process...")
    
    # Parse arguments
    args = parse_arguments()
    
    # Initialize model
    model = initialize_model()
    if not model:
        logger.error("Failed to initialize model. Exiting.")
        return
    
    # Check if input file exists
    final_paper_path = args.input
    if not os.path.exists(final_paper_path):
        logger.error(f"Final paper not found at {final_paper_path}")
        return
    
    # Extract references and content
    pdf_paths, content = extract_references_from_final_paper(final_paper_path)
    
    # Format as academic paper
    formatted_paper = format_as_academic_paper(model, content, pdf_paths)
    
    # Save formatted paper
    output_path = save_formatted_paper(final_paper_path, formatted_paper)
    if output_path:
        logger.info(f"Successfully created academic paper at {output_path}")
        print(f"\nAcademic paper created at: {output_path}")
    else:
        logger.error("Failed to create academic paper")

if __name__ == "__main__":
    main() 